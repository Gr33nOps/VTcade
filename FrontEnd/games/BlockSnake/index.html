<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAKE</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            background: black;
            color: #00ff00;
            font-family: "Courier New", monospace;
            font-size: 16px;
            line-height: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-shadow: 0 0 4px #00ff00;
            overflow: hidden;
            cursor: none;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
            z-index: 1;
        }
        pre {
            white-space: pre;
            user-select: none;
            line-height: 1.0;
        }
        #game {
            position: relative;
        }
        /* CRT scanlines */
        body::after {
            content: "";
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                to bottom,
                rgba(0,0,0,0) 0px,
                rgba(0,255,0,0.04) 2px,
                rgba(0,0,0,0) 4px
            );
            pointer-events: none;
            z-index: 100;
        }
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: black;
            color: #00ff00;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            font-family: "Courier New", monospace;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .loading-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }
        @media (max-width: 768px) {
            body {
                font-size: 12px;
            }
            .container {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
<div class="loading-overlay active" id="loadingOverlay">
    <pre style="font-size: 14px; line-height: 1.5;">
SNAKE v1.0

<span class="loading-dots">LOADING</span>
    </pre>
</div>
<div class="container">
    <pre id="game"></pre>
    <pre id="ui"></pre>
</div>
<script>
const gameEl = document.getElementById("game");
const uiEl = document.getElementById("ui");
const WIDTH = 50;
const HEIGHT = 25;
const GAME_NAME = "SnakeGame";

console.log("Script loaded");

// ---------------- LOGIN CHECK ----------------
const currentUser = localStorage.getItem("currentUser");
console.log("Current user:", currentUser);

if (!currentUser) {
    alert("You must be logged in to play!");
    window.location.href = "../../login/login.html";
}

// Game state
let score = 0;
let highScore = 0;
let gameRunning = false;
let gameStarted = false;
let speed = 150;

// Snake
let snake = [];
let direction = { x: 1, y: 0 };
let nextDirection = { x: 1, y: 0 };

// Food
let food = { x: 0, y: 0 };

// Leaderboard
let leaderboard = [];

// Initialize snake
function initSnake() {
    snake = [
        { x: Math.floor(WIDTH / 2), y: Math.floor(HEIGHT / 2) },
        { x: Math.floor(WIDTH / 2) - 1, y: Math.floor(HEIGHT / 2) },
        { x: Math.floor(WIDTH / 2) - 2, y: Math.floor(HEIGHT / 2) }
    ];
    direction = { x: 1, y: 0 };
    nextDirection = { x: 1, y: 0 };
}

// Spawn food
function spawnFood() {
    let validPosition = false;
    while (!validPosition) {
        food.x = Math.floor(Math.random() * (WIDTH - 2)) + 1;
        food.y = Math.floor(Math.random() * HEIGHT);
        
        validPosition = !snake.some(segment => 
            segment.x === food.x && segment.y === food.y
        );
    }
}

// Drawing
function draw() {
    let out = "";
    
    // Top border
    out += "+" + "=".repeat(WIDTH - 2) + "+\n";
    
    // Game area
    for (let y = 0; y < HEIGHT; y++) {
        let line = "|";
        for (let x = 1; x < WIDTH - 1; x++) {
            let ch = " ";
            
            // Draw snake (head and body same)
            if (snake.some(s => s.x === x && s.y === y)) {
                ch = "â–ˆ";
            }
            // Draw food
            else if (food.x === x && food.y === y) {
                ch = "â–ˆ";
            }
            
            line += ch;
        }
        line += "|\n";
        out += line;
    }
    
    // Bottom border
    out += "+" + "=".repeat(WIDTH - 2) + "+\n";
    
    // Status messages
    if (!gameStarted) {
        out += "< PRESS ARROW KEYS TO START >\n";
    } else if (!gameRunning && gameStarted) {
        out += "< GAME OVER >\nPRESS ANY ARROW KEY TO RESTART\n";
    }
    
    gameEl.textContent = out;
    
    // UI panel
    let ui = `SNAKE v1.0
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

SCORE: ${score}
HIGHSCORE: ${highScore}
LENGTH: ${snake.length}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
LEADERBOARD:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
    
    if (leaderboard.length === 0) {
        ui += "(Loading...)\n";
    } else {
        leaderboard.slice(0, 8).forEach((entry) => {
            // Backend returns { rank, username, score, date }
            const username = entry.username.substring(0, 12).padEnd(12);
            const displayScore = entry.score || 0;
            ui += `${entry.rank}. ${username} ${displayScore}\n`;
        });
    }
    
    ui += `\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
CONTROLS:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ARROW KEYS = MOVE
EAT FOOD [â–ˆ]
AVOID WALLS & SELF

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ESC = BACK TO HOME
`;
    
    uiEl.textContent = ui;
}

// Game loop
function gameLoop() {
    if (!gameRunning) return;
    
    updateSnake();
    
    if (checkCollision()) {
        gameOver();
        return;
    }
    
    draw();
    setTimeout(gameLoop, speed);
}

// Update snake
function updateSnake() {
    direction = nextDirection;
    
    const head = { 
        x: snake[0].x + direction.x, 
        y: snake[0].y + direction.y 
    };
    
    snake.unshift(head);
    
    // Check if snake ate food
    if (head.x === food.x && head.y === food.y) {
        score += 10;
        spawnFood();
        
        // Increase speed slightly
        if (speed > 80) {
            speed -= 2;
        }
    } else {
        snake.pop();
    }
}

// Collision detection
function checkCollision() {
    const head = snake[0];
    
    // Wall collision
    if (head.x < 1 || head.x >= WIDTH - 1 || head.y < 0 || head.y >= HEIGHT) {
        return true;
    }
    
    // Self collision
    for (let i = 1; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) {
            return true;
        }
    }
    
    return false;
}

// ---------------- GAME OVER ----------------
async function gameOver() {
    gameRunning = false;
    console.log("Game over! Score:", score);
    
    // Save personal best and leaderboard
    await saveHighscoreToDB();
    await saveLeaderboardScoreToDB();
    await updateLeaderboardUI();
    
    draw();
}

// ---------------- RESTART ----------------
function restartGame() {
    console.log("Restarting game");
    initSnake();
    spawnFood();
    score = 0;
    speed = 150;
    gameStarted = false;
    gameRunning = false;
    draw();
}

// Start game
function startGame() {
    console.log("Starting game");
    gameRunning = true;
    gameStarted = true;
    gameLoop();
}

// Change direction
function changeDirection(newDir) {
    console.log("Direction change attempt:", newDir, "gameStarted:", gameStarted, "gameRunning:", gameRunning);
    
    // Prevent reversing direction
    if (newDir.x === -direction.x && newDir.y === -direction.y) {
        console.log("Cannot reverse direction");
        return;
    }
    
    if (!gameStarted) {
        console.log("Starting new game");
        nextDirection = newDir;
        startGame();
    } else if (gameRunning) {
        console.log("Changing direction during game");
        nextDirection = newDir;
    } else if (!gameRunning && gameStarted) {
        console.log("Restarting after game over");
        restartGame();
        setTimeout(() => {
            nextDirection = newDir;
            startGame();
        }, 100);
    }
}

// ---------------- HIGH SCORE ----------------
async function loadHighScore() {
    try {
        console.log("Loading highscore for:", currentUser, GAME_NAME);
        
        const res = await fetch(
            `https://vtcade.onrender.com/api/highscore/${currentUser}/${GAME_NAME}`
        );

        if (!res.ok) {
            if (res.status === 404) {
                console.log("No highscore found (404), starting fresh");
                highScore = 0;
                return;
            }
            throw new Error(`HTTP ${res.status}`);
        }

        const data = await res.json();
        highScore = data.highscore || 0;
        
        console.log("âœ“ Loaded highscore:", highScore);
    } catch (err) {
        console.error("Highscore load error:", err);
        highScore = 0;
    }
}

async function saveHighscoreToDB() {
    // Always send to backend - let backend decide with $max operator
    try {
        console.log("Sending score to backend:", score);
        
        const res = await fetch("https://vtcade.onrender.com/api/highscore/save", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                username: currentUser,
                game: GAME_NAME,
                score: score
            })
        });

        if (!res.ok) {
            const errorData = await res.json();
            console.error("Highscore save failed:", errorData);
            throw new Error(`HTTP error! status: ${res.status}`);
        }

        const data = await res.json();
        highScore = data.highscore;
        
        if (data.isNewRecord) {
            console.log("ðŸŽ‰ NEW HIGHSCORE:", highScore);
        } else {
            console.log("Score saved, current highscore remains:", highScore);
        }
    } catch (err) {
        console.error("Highscore save error:", err);
    }
}

// ---------------- LEADERBOARD ----------------
async function saveLeaderboardScoreToDB() {
    try {
        const res = await fetch("https://vtcade.onrender.com/api/leaderboard/save", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                username: currentUser,
                game: GAME_NAME,
                score
            })
        });
        
        if (!res.ok) {
            console.log("Leaderboard save failed:", res.status);
        }
    } catch (err) {
        console.log("Leaderboard save error:", err);
    }
}

async function updateLeaderboardUI() {
    try {
        const res = await fetch(`https://vtcade.onrender.com/api/leaderboard/${GAME_NAME}`);
        
        if (!res.ok) {
            console.log("No leaderboard data available");
            leaderboard = [];
            return;
        }
        
        const data = await res.json();
        
        // Backend returns { game, leaderboard: [...], total }
        // We need the leaderboard array
        leaderboard = data.leaderboard || [];
        
        console.log("Leaderboard loaded:", leaderboard.length, "entries");
        draw();
    } catch (err) {
        console.log("Leaderboard fetch error:", err);
        leaderboard = [];
    }
}

// Controls
document.addEventListener("keydown", (e) => {
    console.log("Key pressed:", e.key, e.code);
    
    if (e.code === "ArrowUp") {
        changeDirection({ x: 0, y: -1 });
        e.preventDefault();
    } else if (e.code === "ArrowDown") {
        changeDirection({ x: 0, y: 1 });
        e.preventDefault();
    } else if (e.code === "ArrowLeft") {
        changeDirection({ x: -1, y: 0 });
        e.preventDefault();
    } else if (e.code === "ArrowRight") {
        changeDirection({ x: 1, y: 0 });
        e.preventDefault();
    } else if (e.code === "Escape" || e.key === "Escape") {
        e.preventDefault();
        const overlay = document.getElementById('loadingOverlay');
        overlay.classList.add('active');
        setTimeout(() => {
            window.location.href = "../../dashboard/dashboard.html";
        }, 800);
    }
});

// Prevent context menu
document.addEventListener("contextmenu", (e) => {
    e.preventDefault();
});

// ---------------- INITIAL ----------------
async function initGame() {
    try {
        console.log("Initializing game for user:", currentUser);
        
        await loadHighScore();
        await updateLeaderboardUI();
        restartGame();
        
        console.log("Game initialized successfully");
        console.log("Press ARROW KEYS to start");
    } catch (err) {
        console.error("Init error:", err);
        restartGame();
    } finally {
        setTimeout(() => {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
            console.log("Loading overlay hidden, game ready");
        }, 500);
    }
}

// Make sure page is fully loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
} else {
    initGame();
}
</script>
</body>
</html>